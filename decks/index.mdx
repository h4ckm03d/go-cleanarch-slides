import { CodeSurfer as Surfer } from "code-surfer";
import { Appear, Background } from "gatsby-theme-mdx-deck";
import Cereal from "../assets/cereal.svg";
import customTheme from "../src/theme";
import * as L from "../src/layout";
export const theme = customTheme;

import FormidableIntro from '../assets/formidable-intro.svg';

<L.Column sx={{ minHeight: '60%', ml: 5 }}>

# Clean Architecture with golang

## by Moch Lutfi
</L.Column>

---


<L.Column>

## Today we'll learn about...

<ul>
  <Appear>
    <li>What is clean architecture</li>
    <li>Charasteritics clean of a architecture</li>
    <li>Clean Architecture principles</li>
    <li>Implementing clean architecture with golang</li>
  </Appear>
</ul>
</L.Column>

---

<L.Column>

## What is clean architecture?

### The way to organized project

To achieve objective...
- Easy to understand
- Easy to change as the project grows
- Independent from external dependency

This doesn't happen by chance. It takes intentional planning...
</L.Column>

<Notes>
Arsitektur disini adalah desain dari sebuah proyek perangkat lunak yang merupakan organisasi kode menjadi sebuah kelas-kelas, berkas-berkas, komponen atau menjadi modul dan bagaimana semua group tersebut berhubungan satu sama lain.
Arsitektur menentukan dimana aplikasi menjalankan fungsionalitas intinya dan bagaimana fungsionalitas tersebut berinteraksi dengan hal-hal seperti database dan antarmuka pengguna. 
Dan pada akhirnya Clean architecture mengacu pada bagaimana mengorganisasi sebuah proyek sehingga mudah dipahami dan mudah diubah seiring dengan pertumbuhan proyek. Ini tidak terjadi secara kebetulan. Itu membutuhkan perencanaan yang disengaja.
</Notes>

---

<Background />

<L.Row>
<Cereal />

### We've now learned about the moon view of clean architecture definition

</L.Row>

---

## Characteristics of a clean architecture

---

<L.Row>

## ugh

import RuwetDependency from '../assets/clean-architecture-ex-1.jpeg';

<img src={RuwetDependency}/>
</L.Row>

<Notes>
Pada gambar di atas, jika Anda ingin mengganti gunting dengan pisau, apa yang harus Anda lakukan? Anda harus melepaskan tali yang ada di pena, botol tinta, selotip, dan kompas. Kemudian Anda harus mengikat kembali barang-barang itu ke pisau. Mungkin itu berhasil untuk pisaunya, tetapi bagaimana jika pena dan selotip mengatakan, "Tunggu, kami membutuhkan gunting." Jadi sekarang pena dan selotip tidak berfungsi dan harus diganti, yang pada gilirannya mempengaruhi objek yang terikat padanya. Ini berantakan.
</Notes>

---

<L.Row>

## much better

import StarDependency from '../assets/clean-architecture-ex-2.jpeg';

<img src={StarDependency} />

<Notes>
Sekarang bagaimana cara mengganti gunting? Kita hanya perlu mencabut tali gunting dari bawah catatan Post-it dan menambahkan tali baru yang diikat ke pisau. Jauh lebih mudah. Catatan Post-it tidak peduli karena senar itu bahkan tidak terikat padanya.

Arsitektur yang diwakili oleh gambar kedua jelas lebih mudah diubah. Selama catatan Post-it tidak perlu sering diubah, sistem ini akan sangat mudah dipelihara. Konsep yang sama adalah arsitektur yang akan membuat perangkat lunak Anda mudah dipelihara dan diubah.
</Notes>
</L.Row>

---

import DomainLayer from '../assets/clean-architecture-ex-3.png';

<img src={DomainLayer} />

domain layer vs infrastructure


<Notes>
The inner circle is the domain layer of your application. This is where you put the business rules. By "business" we don't necessarily mean a company. It just means the essence of what your application does, the core functionality of the code. A translation app translates. An online store has products to sell. These business rules tend to be fairly stable since you are not likely to change the essence of what your app does very often.

The outer circle is the infrastructure. It includes things like the UI, the database, web APIs, and frameworks. These things are more likely to change than the domain. For example, you are more likely to change how a UI button looks than you are to change how a loan is calculated.

A boundary between the domain and the infrastructure is set up so that the domain doesn't know anything about the infrastructure. That means the UI and the database depend on the business rules, but the business rules don't depend on the UI or database. This makes it a plugin architecture. It doesn't matter if the UI is a web interface, a desktop app, or a mobile app. It doesn't matter if the data is stored using SQL or NoSQL or in the cloud. The domain doesn't care. This makes it easy to change the infrastructure.

</Notes>

---

<L.Row>

## Defining `terms`

### Entities

</L.Row>

import DetailLayer from '../assets/clean-architecture-ex-4.png';

<img src={DetailLayer} />

<Notes>
Here the domain layer is subdivided into *entities* and *use cases*, and an *adapter* layer forms the border between the domain and the infrastructure layer. These terms can be a little confusing. Let's look at them individually.
The entities know nothing of the other layers. They don't depend on anything. That is, they don't use the names of any other classes or components that are in the outer layers.
</Notes>

---

<L.Row>

## Defining `terms`

### Entities (2)

</L.Row>

import TodoClass from '../assets/todo.png';

<img src={TodoClass} />

- The entities know nothing of the other layers. 
- They don't depend on anything.
---

<Surfer>

```go title="Todo entity"
// Todo respresent a record stored in todos table.
type Todo struct {
	ID        uint      `json:"id"`
	Title     string    `json:"title"`
	Order     int       `json:"order"`
	Completed bool      `json:"completed"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}
```

```go title="todo validation"

// Todo respresent a record stored in todos table.
type Todo struct {
	ID        uint      `json:"id"`
	Title     string    `json:"title"`
	Order     int       `json:"order"`
	Completed bool      `json:"completed"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

// Validate todo.
func (t Todo) Validate() error {
	var err error
	switch {
	case len(t.Title) == 0:
		err = ErrTodoTitleBlank
	}

	return err
}
```

</Surfer>

---

<L.Row>

## Defining `terms`

### Use cases

</L.Row>

<img src={DetailLayer} />

---

<L.Row>

## Defining `terms`

### Use cases (2)

</L.Row>

```
    Create New Todo Item

    Input:  Title, Order, Completed, etc.
    Output: error info

    Rules:
      1. Validate title
      2. Validate order, etc.
      3. If completed then earn score and create todo
      4. Else create Todo (entity)
```
<Notes>
The use cases are the business rules for a specific application. They tell how to automate the system. This determines the behavior of the app. Here is an example from the book of the business rules for a use case (p. 192, somewhat modified):
</Notes>

---

<Surfer>

```go title="declare composite struct to implement Create"

type create struct {
	repository rel.Repository
	scores     scores.Service
}

```

```go title="implement Create todo with validation and update score"

type create struct {
	repository rel.Repository
	scores     scores.Service
}

func (c create) Create(ctx context.Context, todo *Todo) error {
	if err := todo.Validate(); err != nil {
		logger.Warn("validation error", zap.Error(err))
		return err
	}

	// if completed, then earn a point.
	if todo.Completed {
		return c.repository.Transaction(ctx, func(ctx context.Context) error {
			c.repository.MustInsert(ctx, todo)
			return c.scores.Earn(ctx, "todo completed", 1)
		})
	}

	c.repository.MustInsert(ctx, todo)
	return nil
}


```

```diff 8:11 title="Validate input"
```

```diff 13:19 title="earn point and save database if completed"
```

```diff 21 title="save to database"
```

</Surfer>

---

<L.Row>

## Defining `terms`

### Adapters

</L.Row>

<img src={DetailLayer} />

<Notes>
The adapters, also called interface adapters, are the translators between the domain and the infrastructure. For example, they take input data from the GUI and repackage it in a form that is convenient for the use cases and entities. Then they take the output from the use cases and entities and repackage it in a form that is convenient for displaying in the GUI or saving in a database.
</Notes>

---

<Surfer>

```go

// Service instance for todo's domain.
// Any operation done to any of object within this domain should use this service.
type Service interface {
	Get(ctx context.Context, todo *Todo, id uint) error
	Search(ctx context.Context, todos *[]Todo, filter Filter) error
	Create(ctx context.Context, todo *Todo) error
	Update(ctx context.Context, todo *Todo, changes rel.Changeset) error
	Delete(ctx context.Context, todo *Todo)
	Clear(ctx context.Context)
}

```

```go title="beside embeding the struct, you can also declare the function directly on this struct. "

// Service instance for todo's domain.
// Any operation done to any of object within this domain should use this service.
type Service interface {
	Get(ctx context.Context, todo *Todo, id uint) error
	Search(ctx context.Context, todos *[]Todo, filter Filter) error
	Create(ctx context.Context, todo *Todo) error
	Update(ctx context.Context, todo *Todo, changes rel.Changeset) error
	Delete(ctx context.Context, todo *Todo)
	Clear(ctx context.Context)
}

type service struct {
	get
	search
	create
	update
	delete
	clear
}

```

```go title="make sure all interface already implemented on service"

// Service instance for todo's domain.
// Any operation done to any of object within this domain should use this service.
type Service interface {
	Get(ctx context.Context, todo *Todo, id uint) error
	Search(ctx context.Context, todos *[]Todo, filter Filter) error
	Create(ctx context.Context, todo *Todo) error
	Update(ctx context.Context, todo *Todo, changes rel.Changeset) error
	Delete(ctx context.Context, todo *Todo)
	Clear(ctx context.Context)
}

type service struct {
	get
	search
	create
	update
	delete
	clear
}

var _ Service = (*service)(nil)

```

</Surfer>

---

<L.Row>

## Defining `terms`

### Infrastructure

</L.Row>

<img src={DetailLayer} />

---

<L.Row>

## Defining `terms`

### Infrastructure (2)

</L.Row>

- User Interface
- Database
- Framework
- Device

Since the things in this layer are so likely to change, they are kept as far away as possible from the more stable domain layers

---

<L.Column>

## Principles for implementing `clean architecture`

- SOLID principles
- Reuse/Release Equivalence Principle (REP)
- Common Closure Principle (CCP)
- Common Reuse Principle (CRP)
- Acyclic Dependency Principle (ADP)
- Stable Dependency Principle (SDP)
- Stable Abstraction Principle (SAP)

</L.Column>

---

<Background />
<L.Row>

## SOLID principles

<Cereal />
</L.Row>

- Single Responsibility Principle (known as SRP)
- Open/Closed Principle
- Liskov’s Substitution Principle
- Interface Segregation Principle
- Dependency Inversion Principle

---

<L.Row>

## Single Responsibility Principle

### A class should have one, and only one, reason to change. (Robert C Martin)

</L.Row>



- Is my method a behavior of my struct ?
- Is my struct tightly coupled with another struct ?
- Could my method be applied differently ?

<Notes>
As Dave Cheney says :
The Single Responsibility Principle encourages you to structure the functions, types, and methods into packages that exhibit natural cohesion; the types belong together, the functions serve a single purpose.
</Notes>

---

<Notes>"Could I “Save” my struct in another location ? Maybe tomorrow I would like to save in a file, or in a DataBase."</Notes>
<Surfer>

```go title="Could my method be applied differently ?"

type A struct {
    Content string
    ....
}
func (a A) Save() {
 fmt.Println("Saving in the Terminal .... " + a.Content)
}

```

```go title="So the code should be"

type A struct {
    Content string
    .....
}
type APersistence struct {
}
func (ap APersistence) Save(a A) {
    fmt.Println("Saving in the Terminal .... " + a.Content)
}

```

</Surfer>

---

<L.Row>

## Open/Closed Principle

###  Software entities should be open for extension, but closed for modification - Bertrand Meyer

</L.Row>

- be able to override a struct

---

<Surfer>

```go title="Be able to override a struct"
package main

type A struct {
        year int
}

func (a A) Greet() { fmt.Println("Hello Technology", a.year) }

type B struct { A }

func (b B) Greet() { fmt.Println("Welcome to Bukalapak", b.year) }

func main() {
        var a A
        a.year = 2020
        var b B
        b.year = 2020
        a.Greet() // Hello Technology 2020
        b.Greet() // Welcome to Bukalapak 2020
}

```

```go
package main

type Cat struct {
        Name string
}

func (c Cat) Legs() int { return 4 }

func (c Cat) PrintLegs() {
        fmt.Printf("I have %d legs\n", c.Legs())
}

type OctoCat struct {
        Cat
}

func (o OctoCat) Legs() int { return 5 }

func main() {
        var octo OctoCat
        fmt.Println(octo.Legs()) // 5
        octo.PrintLegs()         // I have 4 legs
}
```

```go

package main

type Cat struct {
        Name string
}

func (c Cat) Legs() int { return 4 }

func (c Cat) PrintLegs() {
        fmt.Printf("I have %d legs\n", c.Legs())
}

type OctoCat struct {
        Cat
}

func (o OctoCat) Legs() int { return 5 }

func main() {
        var octo OctoCat
        fmt.Println(octo.Legs()) // 5
        octo.PrintLegs()         // I have 4 legs
}
func PrintLegs(c Cat) {
        fmt.Printf("I have %d legs\n", c.Legs())
}
```


</Surfer>

---

<L.Row>

## Liskov’s Substitution Principle

### Subtypes must be substitutable for their base types. (Robert C. Martin)

</L.Row>

<Notes>
According to that definition golang is safe from LSP, because in golang we don’t have inherintance, we have a more powerful tool that is the composition.
Anyway composition does not allow to substitute parent struct by child struct.
</Notes>

---

<Surfer>

```go title="will panic"

type A struct {}

func (a A) Test() {
     fmt.Println("Printing A")
}

type B struct { A }

func ImpossibleLiskovSubstitution(a A) {
    a.Test()
}

func main() {
   a := B{}
   ImpossibleLiskovSubstitution(a) 
   // PANIC : cannot use a (type B) as type A in argument to ImpossibleLiskovSubstitution
}

```

```go title="pass interface in the args"

type A struct {}

type tester interface {
    Test()
}

func (a A) Test() {
     fmt.Println("Printing A")
}
type B struct { A }

func PossibleLiskovSubstitution(a tester) {
    a.Test()
}

func main() {
   a := B{}
   PossibleLiskovSubstitution(a)
}

```

</Surfer>

---

<L.Row>

## Interface Segregation Principle

### Clients should not be forced to depend on methods they do not use. (Robert C. Martin)

</L.Row>

--- 

<Surfer>

```go

// Save writes the contents of doc to the file f.
func Save(f *os.File, doc *Document) error

```

```go

// Save writes the contents of doc to the supplied ReadWriterCloser.
func Save(rwc io.ReadWriteCloser, doc *Document) error

```

```go 

// Save writes the contents of doc to the supplied WriteCloser.
func Save(wc io.WriteCloser, doc *Document) error

```

```go

// Save writes the contents of doc to the supplied Writer.
func Save(w io.Writer, doc *Document) error

```

</Surfer>

---

<L.Column>

## Dependency Inversion Principle

### High-level modules should not depend on low-level modules. Both should depend on abstractions.
Abstractions should not depend on details. Details should depend on abstractions.
–Robert C. Martin

</L.Column>

---


<FormidableIntro />

More Questions? [@kaptenupi](https://twitter.com/kaptenupi) 

